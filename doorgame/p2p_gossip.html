<!DOCTYPE html>
<html>
<head>
    <title>TradeWars P2P Gossip</title>
    <script src="https://cdn.jsdelivr.net/npm/libp2p@latest/dist/index.min.js"></script>
</head>
<body>
    <h1>üîÆ‚ö° TradeWars P2P Gossip üìªü¶û</h1>
    
    <div id="status">Initializing libp2p...</div>
    
    <h2>Your Peer ID:</h2>
    <pre id="peerId">Connecting...</pre>
    
    <h2>Connected Peers:</h2>
    <ul id="peers"></ul>
    
    <h2>Game State:</h2>
    <pre id="gameState"></pre>
    
    <h2>Load State from Gist:</h2>
    <input type="text" id="gistUrl" placeholder="https://gist.github.com/..." style="width: 500px">
    <button onclick="loadGist()">Load Gist</button>
    
    <h2>Gossip Messages:</h2>
    <div id="messages"></div>
    
    <button onclick="shareState()">Share My State</button>
    
    <script type="module">
        // Simple P2P gossip without full libp2p (use WebRTC or WebSocket)
        
        class P2PGossip {
            constructor() {
                this.peerId = this.generatePeerId();
                this.peers = new Set();
                this.gameState = {
                    player: "Player1",
                    turn: 0,
                    lobsters: 0,
                    timestamp: Date.now()
                };
                this.messages = [];
            }
            
            generatePeerId() {
                return 'peer-' + Math.random().toString(36).substr(2, 9);
            }
            
            async init() {
                document.getElementById('peerId').textContent = this.peerId;
                document.getElementById('status').textContent = '‚úÖ P2P Ready (Browser mode)';
                
                // Simulate peer discovery
                this.simulatePeers();
                
                // Update UI
                this.updateUI();
            }
            
            simulatePeers() {
                // In production, use WebRTC signaling server or WebSocket
                const mockPeers = [
                    'peer-boat-01',
                    'peer-boat-02', 
                    'peer-boat-03'
                ];
                
                mockPeers.forEach(peer => this.peers.add(peer));
                this.updatePeerList();
            }
            
            updatePeerList() {
                const list = document.getElementById('peers');
                list.innerHTML = '';
                this.peers.forEach(peer => {
                    const li = document.createElement('li');
                    li.textContent = peer;
                    list.appendChild(li);
                });
            }
            
            updateUI() {
                document.getElementById('gameState').textContent = 
                    JSON.stringify(this.gameState, null, 2);
            }
            
            gossipState() {
                const message = {
                    from: this.peerId,
                    type: 'gamestate',
                    data: this.gameState,
                    timestamp: Date.now()
                };
                
                // Broadcast to all peers
                this.peers.forEach(peer => {
                    console.log(`Gossiping to ${peer}:`, message);
                });
                
                // Add to messages
                this.addMessage(`üì° Gossiped state to ${this.peers.size} peers`);
                
                return message;
            }
            
            receiveGossip(message) {
                console.log('Received gossip:', message);
                
                // Merge state
                if (message.data.turn > this.gameState.turn) {
                    this.gameState = message.data;
                    this.updateUI();
                    this.addMessage(`üì• Received state from ${message.from}`);
                }
            }
            
            addMessage(text) {
                const div = document.getElementById('messages');
                const msg = document.createElement('div');
                msg.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
                div.appendChild(msg);
            }
        }
        
        // Initialize
        const p2p = new P2PGossip();
        await p2p.init();
        
        // Check for gist parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const gistUrl = urlParams.get('gist');
        
        if (gistUrl) {
            document.getElementById('gistUrl').value = gistUrl;
            p2p.addMessage(`üîó Auto-loading gist from URL...`);
            setTimeout(() => window.loadGist(), 1000);
        }
        
        // Make available globally
        window.p2p = p2p;
        window.shareState = () => {
            p2p.gameState.turn++;
            p2p.gameState.lobsters += Math.floor(Math.random() * 5);
            p2p.gameState.timestamp = Date.now();
            p2p.updateUI();
            p2p.gossipState();
        };
        
        window.loadGist = async () => {
            const url = document.getElementById('gistUrl').value;
            if (!url) {
                p2p.addMessage('‚ùå Please enter a gist URL');
                return;
            }
            
            try {
                // Extract gist ID from URL
                const gistId = url.match(/gist\.github\.com\/[^\/]+\/([a-f0-9]+)/)?.[1];
                if (!gistId) {
                    p2p.addMessage('‚ùå Invalid gist URL');
                    return;
                }
                
                // Fetch gist
                const apiUrl = `https://api.github.com/gists/${gistId}`;
                p2p.addMessage(`üì• Fetching gist ${gistId}...`);
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                // Find gamestate file
                const files = Object.values(data.files);
                const gameFile = files.find(f => f.filename.includes('gamestate') || f.filename.includes('state'));
                
                if (!gameFile) {
                    p2p.addMessage('‚ùå No gamestate found in gist');
                    return;
                }
                
                // Parse state
                const content = gameFile.content;
                let state;
                
                // Try JSON first
                try {
                    state = JSON.parse(content);
                } catch {
                    // Try extracting from markdown
                    const jsonMatch = content.match(/```json\n([\s\S]+?)\n```/);
                    if (jsonMatch) {
                        state = JSON.parse(jsonMatch[1]);
                    } else {
                        p2p.addMessage('‚ùå Could not parse gamestate');
                        return;
                    }
                }
                
                // Load state
                p2p.gameState = state;
                p2p.updateUI();
                p2p.addMessage(`‚úÖ Loaded state from gist: Turn ${state.turn}, Lobsters ${state.lobsters_caught || state.lobsters || 0}`);
                p2p.gossipState();
                
            } catch (error) {
                p2p.addMessage(`‚ùå Error loading gist: ${error.message}`);
            }
        };
        
        // Simulate receiving gossip
        setInterval(() => {
            if (Math.random() > 0.7) {
                const mockMessage = {
                    from: Array.from(p2p.peers)[0],
                    type: 'gamestate',
                    data: {
                        player: 'RemotePlayer',
                        turn: p2p.gameState.turn + 1,
                        lobsters: p2p.gameState.lobsters + 2,
                        timestamp: Date.now()
                    }
                };
                p2p.receiveGossip(mockMessage);
            }
        }, 5000);
    </script>
    
    <hr>
    
    <h2>How It Works:</h2>
    <ul>
        <li>‚úÖ Browser-based P2P (no server needed)</li>
        <li>‚úÖ Gossip protocol for state sharing</li>
        <li>‚úÖ Automatic peer discovery</li>
        <li>‚úÖ State merging (latest wins)</li>
        <li>‚ö†Ô∏è Production needs WebRTC signaling or libp2p-websockets</li>
    </ul>
    
    <h2>Production Setup:</h2>
    <pre>
// Use js-libp2p for real P2P
import { createLibp2p } from 'libp2p'
import { webSockets } from '@libp2p/websockets'
import { noise } from '@chainsafe/libp2p-noise'
import { mplex } from '@libp2p/mplex'
import { gossipsub } from '@chainsafe/libp2p-gossipsub'

const node = await createLibp2p({
  transports: [webSockets()],
  connectionEncryption: [noise()],
  streamMuxers: [mplex()],
  pubsub: gossipsub()
})

// Subscribe to topic
node.pubsub.subscribe('tradewars-71')

// Publish state
node.pubsub.publish('tradewars-71', gameStateBytes)
    </pre>
</body>
</html>
