<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ğŸ“ Monster Ship Loadout - BBS Door Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  background: #000;
  color: #0f0; 
  font-family: 'Courier New', monospace; 
  overflow: hidden;
}
#terminal {
  width: 100vw; height: 100vh;
  background: #000;
  color: #0f0;
  padding: 20px;
  overflow-y: auto;
  font-size: 14px;
  line-height: 1.4;
}
.blink { animation: blink 1s infinite; }
@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
.prime { cursor: pointer; padding: 2px; }
.prime:hover { background: #0f0; color: #000; }
.active { background: #0f0; color: #000; }
.tunnel { color: #f0f; }
#canvas { display: none; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="terminal"></div>

<script type="module">
// ZK-RDF URL Payload Parser
function parseZkRdfUrl() {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;
  try {
    return JSON.parse(atob(hash));
  } catch {
    return null;
  }
}

// Monster Prime Data (from autolabels)
const PRIMES = [
  {p: 2, e: 'âš›ï¸', r: 'Source', t: 2, f: 14, c: 0.96},
  {p: 3, e: 'ğŸŒ³', r: 'Life', t: 3, f: 10, c: 0.67},
  {p: 5, e: 'ğŸŒŠ', r: 'Source', t: 5, f: 9, c: 0.62},
  {p: 7, e: 'ğŸ”®', r: 'Source', t: 7, f: 9, c: 0.60},
  {p: 11, e: 'ğŸ”±', r: 'Hub', t: 1, f: 15, c: 1.00},
  {p: 13, e: 'ğŸŒ³', r: 'Life', t: 3, f: 15, c: 1.00},
  {p: 17, e: 'ğŸ”®', r: 'Connect', t: 7, f: 9, c: 0.64},
  {p: 19, e: 'ğŸŒŒ', r: 'Connect', t: 9, f: 8, c: 0.58},
  {p: 23, e: 'ğŸŒ³', r: 'Life', t: 3, f: 9, c: 0.62},
  {p: 29, e: 'ğŸŒŒ', r: 'Sink', t: 9, f: 10, c: 0.70},
  {p: 31, e: 'ğŸ”±', r: 'Sink', t: 1, f: 9, c: 0.63},
  {p: 41, e: 'ğŸ”±', r: 'Sink', t: 1, f: 8, c: 0.53},
  {p: 47, e: 'ğŸ”®', r: 'Sink', t: 7, f: 9, c: 0.60},
  {p: 59, e: 'ğŸŒŒ', r: 'Sink', t: 9, f: 9, c: 0.64},
  {p: 71, e: 'ğŸ”±', r: 'Rooster', t: 1, f: 8, c: 0.57}
];

// Ship state
let ship = {
  primes: new Set([2, 13, 71]),
  tunnels: [[2, 13], [13, 71]],
  sidechannels: []
};

// Load from ZK-RDF URL
const zkPayload = parseZkRdfUrl();
if (zkPayload && zkPayload.ship) {
  ship = zkPayload.ship;
  ship.primes = new Set(ship.primes);
}

// Terminal output
const term = document.getElementById('terminal');
function print(s) {
  term.innerHTML += s + '\n';
  term.scrollTop = term.scrollHeight;
}

function clear() {
  term.innerHTML = '';
}

// BBS Door Game UI
function render() {
  clear();
  print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  print('â•‘         ğŸ“ MONSTER SHIP LOADOUT - BBS DOOR GAME          â•‘');
  print('â•‘              ZX81/8080 WASM Emulator v1.0                â•‘');
  print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  print('');
  print('SHIP STATUS:');
  
  const total = Array.from(ship.primes).reduce((s, p) => {
    const pr = PRIMES.find(x => x.p === p);
    return s + (pr ? pr.f : 0);
  }, 0);
  
  const bdi = Array.from(ship.primes).filter(p => p % 10 === 3).length;
  const hasRooster = ship.primes.has(71);
  
  print(`  Primes Loaded: ${ship.primes.size}/15`);
  print(`  Flow Rate: ${total}M decls/s`);
  print(`  ğŸŒ³ BDI Life: ${bdi}`);
  print(`  ğŸ“ Rooster: ${hasRooster ? '<span class="blink">ACTIVE</span>' : 'offline'}`);
  print(`  ğŸ”€ Tunnels: ${ship.tunnels.length}`);
  print(`  ğŸ“¡ Sidechannels: ${ship.sidechannels.length}`);
  print('');
  print('MONSTER PRIMES:');
  print('');
  
  PRIMES.forEach((pr, i) => {
    const active = ship.primes.has(pr.p);
    const cls = active ? 'prime active' : 'prime';
    const marker = active ? 'â–ˆ' : 'â–‘';
    print(`  <span class="${cls}" data-prime="${pr.p}">${marker} ${i+1}. ${pr.e} ${pr.p} ${pr.r.padEnd(8)} ${pr.f}M (${(pr.c*100).toFixed(0)}%)</span>`);
  });
  
  print('');
  print('SIDECHANNEL TUNNELS:');
  ship.tunnels.forEach((t, i) => {
    const depth = ship.sidechannels.filter(s => s[0] === t[0] && s[1] === t[1]).length;
    const nested = depth > 0 ? ` ${'ğŸ“¡'.repeat(depth)}` : '';
    print(`  <span class="tunnel">ğŸ”€ ${t[0]} â‡„ ${t[1]}${nested}</span>`);
  });
  
  print('');
  print('COMMANDS:');
  print('  [1-15] Toggle prime   [T] Add tunnel   [S] Sidechannel');
  print('  [C] Clear tunnels     [E] Export tape  [L] Load local');
  print('  [G] Save to Gist      [P] Show proof  [X] Trade offer');
  print('  [Q] Quit');
  print('');
  print('> <span class="blink">_</span>');
  
  // Add click handlers
  document.querySelectorAll('.prime').forEach(el => {
    el.onclick = () => {
      const p = parseInt(el.dataset.prime);
      if (ship.primes.has(p)) {
        ship.primes.delete(p);
      } else {
        ship.primes.add(p);
      }
      render();
    };
  });
}

// Keyboard input
document.addEventListener('keydown', e => {
  const key = e.key.toUpperCase();
  
  if (key >= '1' && key <= '9') {
    const idx = parseInt(key) - 1;
    if (idx < PRIMES.length) {
      const p = PRIMES[idx].p;
      if (ship.primes.has(p)) ship.primes.delete(p);
      else ship.primes.add(p);
      render();
    }
  } else if (key === 'T') {
    const primes = Array.from(ship.primes);
    if (primes.length >= 2) {
      const a = primes[Math.floor(Math.random() * primes.length)];
      const b = primes[Math.floor(Math.random() * primes.length)];
      if (a !== b) ship.tunnels.push([a, b]);
      render();
    }
  } else if (key === 'S') {
    if (ship.tunnels.length > 0) {
      const t = ship.tunnels[Math.floor(Math.random() * ship.tunnels.length)];
      ship.sidechannels.push([t[0], t[1]]);
      render();
    }
  } else if (key === 'C') {
    ship.tunnels = [];
    ship.sidechannels = [];
    render();
  } else if (key === 'E') {
    exportTape();
  } else if (key === 'L') {
    loadLocal();
  } else if (key === 'G') {
    saveGist();
  } else if (key === 'P') {
    showProof();
  } else if (key === 'X') {
    exportTrade();
  } else if (key === 'Q') {
    print('');
    print('Disconnecting from BBS...');
    print('NO CARRIER');
  }
});

// ZK Proof: Monster Conformance
async function generateZkProof(shipData) {
  const primes = Array.from(shipData.primes);
  
  // Compute public commitments (no private data revealed)
  const commitment = await crypto.subtle.digest('SHA-256', 
    new TextEncoder().encode(JSON.stringify(primes.sort()))
  );
  const commitmentHex = Array.from(new Uint8Array(commitment))
    .map(b => b.toString(16).padStart(2, '0')).join('');
  
  // Monster conformance checks (public)
  const hasBDI = primes.some(p => p % 10 === 3);
  const hasRooster = primes.includes(71);
  const totalFlow = primes.reduce((s, p) => {
    const pr = PRIMES.find(x => x.p === p);
    return s + (pr ? pr.f : 0);
  }, 0);
  const isConformant = hasBDI && totalFlow >= 10;
  
  return {
    commitment: commitmentHex,
    conformant: isConformant,
    properties: {
      hasBDI,
      hasRooster,
      primeCount: primes.length,
      flowRate: totalFlow,
      tunnelCount: shipData.tunnels.length
    },
    timestamp: new Date().toISOString()
  };
}

// Save to localStorage
function saveLocal() {
  const data = {
    primes: Array.from(ship.primes),
    tunnels: ship.tunnels,
    sidechannels: ship.sidechannels
  };
  localStorage.setItem('monster-ship', JSON.stringify(data));
  print('âœ“ Saved to localStorage');
}

// Load from localStorage
function loadLocal() {
  const data = localStorage.getItem('monster-ship');
  if (data) {
    const loaded = JSON.parse(data);
    ship.primes = new Set(loaded.primes);
    ship.tunnels = loaded.tunnels || [];
    ship.sidechannels = loaded.sidechannels || [];
    print('âœ“ Loaded from localStorage');
    render();
  }
}

// Save to private GitHub Gist
async function saveGist() {
  const token = prompt('GitHub token (will not be stored):');
  if (!token) return;
  
  const zkProof = await generateZkProof(ship);
  
  const gistData = {
    description: 'Monster Ship Loadout (ZK-Proof)',
    public: false,
    files: {
      'monster-ship.json': {
        content: JSON.stringify({
          ship: {
            primes: Array.from(ship.primes),
            tunnels: ship.tunnels,
            sidechannels: ship.sidechannels
          },
          zkProof
        }, null, 2)
      },
      'zk-proof.json': {
        content: JSON.stringify(zkProof, null, 2)
      }
    }
  };
  
  try {
    const resp = await fetch('https://api.github.com/gists', {
      method: 'POST',
      headers: {
        'Authorization': `token ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(gistData)
    });
    
    const result = await resp.json();
    print('');
    print('âœ“ Saved to private Gist:');
    print(result.html_url);
    print('');
    print('ZK Proof Commitment: ' + zkProof.commitment.slice(0, 16) + '...');
    print('Monster Conformant: ' + (zkProof.conformant ? 'YES âœ“' : 'NO âœ—'));
  } catch (e) {
    print('âœ— Error: ' + e.message);
  }
}

// Export as ZK-RDF URL
async function exportTape() {
  const zkProof = await generateZkProof(ship);
  
  const tape = {
    version: '1.0',
    type: 'MonsterShipLoadout',
    ship: {
      primes: Array.from(ship.primes),
      tunnels: ship.tunnels,
      sidechannels: ship.sidechannels
    },
    zkProof,
    timestamp: new Date().toISOString()
  };
  
  const encoded = btoa(JSON.stringify(tape));
  const url = window.location.origin + window.location.pathname + '#' + encoded;
  
  print('');
  print('TAPE EXPORTED (ZK-RDF):');
  print('');
  print(url);
  print('');
  print('ZK Proof:');
  print('  Commitment: ' + zkProof.commitment.slice(0, 32) + '...');
  print('  Conformant: ' + (zkProof.conformant ? 'YES âœ“' : 'NO âœ—'));
  print('  BDI: ' + (zkProof.properties.hasBDI ? 'YES' : 'NO'));
  print('  Rooster: ' + (zkProof.properties.hasRooster ? 'YES' : 'NO'));
  print('  Flow: ' + zkProof.properties.flowRate + 'M');
  print('');
  
  // Save to localStorage
  saveLocal();
  
  // Copy to clipboard
  navigator.clipboard.writeText(url).then(() => {
    print('âœ“ Copied to clipboard!');
  });
}

// Show ZK proof without revealing data
async function showProof() {
  const zkProof = await generateZkProof(ship);
  
  print('');
  print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  print('â•‘              ZK PROOF: MONSTER CONFORMANCE                â•‘');
  print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  print('');
  print('Commitment (SHA-256):');
  print('  ' + zkProof.commitment);
  print('');
  print('Public Properties (no private data revealed):');
  print('  Monster Conformant: ' + (zkProof.conformant ? 'âœ“ YES' : 'âœ— NO'));
  print('  Has BDI (Life): ' + (zkProof.properties.hasBDI ? 'YES' : 'NO'));
  print('  Has Rooster (71): ' + (zkProof.properties.hasRooster ? 'YES' : 'NO'));
  print('  Prime Count: ' + zkProof.properties.primeCount + '/15');
  print('  Flow Rate: ' + zkProof.properties.flowRate + 'M decls/s');
  print('  Tunnel Count: ' + zkProof.properties.tunnelCount);
  print('');
  print('Timestamp: ' + zkProof.timestamp);
  print('');
  print('This proof demonstrates Monster conformance without');
  print('revealing your exact prime selection or tunnel configuration.');
  print('');
}

// Selective disclosure for trading
function createTradeOffer(disclosureLevel) {
  const primes = Array.from(ship.primes);
  
  let disclosed = {};
  
  if (disclosureLevel === 'minimal') {
    // Only public stats
    disclosed = {
      type: 'minimal',
      primeCount: primes.length,
      hasBDI: primes.some(p => p % 10 === 3),
      hasRooster: primes.includes(71)
    };
  } else if (disclosureLevel === 'partial') {
    // Reveal some primes, hide others
    const revealed = primes.slice(0, Math.floor(primes.length / 2));
    disclosed = {
      type: 'partial',
      revealedPrimes: revealed,
      hiddenCount: primes.length - revealed.length,
      totalFlow: primes.reduce((s, p) => {
        const pr = PRIMES.find(x => x.p === p);
        return s + (pr ? pr.f : 0);
      }, 0)
    };
  } else if (disclosureLevel === 'tunnels') {
    // Reveal tunnel structure but not endpoints
    disclosed = {
      type: 'tunnels',
      tunnelCount: ship.tunnels.length,
      sidechannelCount: ship.sidechannels.length,
      tunnelStrengths: ship.tunnels.map(t => {
        const p1 = PRIMES.find(x => x.p === t[0]);
        const p2 = PRIMES.find(x => x.p === t[1]);
        return (p1?.f || 0) + (p2?.f || 0);
      })
    };
  } else if (disclosureLevel === 'full') {
    // Full disclosure for trusted trades
    disclosed = {
      type: 'full',
      primes: primes,
      tunnels: ship.tunnels,
      sidechannels: ship.sidechannels
    };
  }
  
  return {
    version: '1.0',
    type: 'MonsterTradeOffer',
    disclosure: disclosureLevel,
    data: disclosed,
    timestamp: new Date().toISOString()
  };
}

async function exportTrade() {
  print('');
  print('TRADE OFFER DISCLOSURE LEVELS:');
  print('');
  print('  [1] Minimal - Stats only (safe for public)');
  print('  [2] Partial - Reveal half your primes');
  print('  [3] Tunnels - Show tunnel structure only');
  print('  [4] Full - Complete loadout (trusted only)');
  print('');
  print('Select level (1-4): ');
  
  // Wait for input
  const handler = (e) => {
    const key = e.key;
    if (key >= '1' && key <= '4') {
      document.removeEventListener('keydown', handler);
      
      const levels = ['minimal', 'partial', 'tunnels', 'full'];
      const level = levels[parseInt(key) - 1];
      const offer = createTradeOffer(level);
      
      const encoded = btoa(JSON.stringify(offer));
      const url = window.location.origin + window.location.pathname + '?trade=' + encoded;
      
      print('');
      print('TRADE OFFER CREATED:');
      print('');
      print('Disclosure: ' + level.toUpperCase());
      print('');
      print(url);
      print('');
      
      if (level === 'minimal') {
        print('âœ“ Safe to share publicly');
        print('  Only stats revealed, no primes');
      } else if (level === 'partial') {
        print('âš  Partial disclosure');
        print('  ' + offer.data.revealedPrimes.length + ' primes revealed, ' + offer.data.hiddenCount + ' hidden');
      } else if (level === 'tunnels') {
        print('âš  Tunnel structure revealed');
        print('  Endpoints hidden, strengths shown');
      } else {
        print('âš ï¸ FULL DISCLOSURE - trusted trades only!');
      }
      
      print('');
      navigator.clipboard.writeText(url).then(() => {
        print('âœ“ Copied to clipboard!');
      });
      
      render();
    }
  };
  
  document.addEventListener('keydown', handler);
}

// Load trade offer
function loadTradeOffer() {
  const params = new URLSearchParams(window.location.search);
  const trade = params.get('trade');
  
  if (trade) {
    try {
      const offer = JSON.parse(atob(trade));
      
      print('');
      print('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
      print('â•‘                  TRADE OFFER RECEIVED                     â•‘');
      print('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      print('');
      print('Disclosure Level: ' + offer.disclosure.toUpperCase());
      print('Timestamp: ' + offer.timestamp);
      print('');
      
      if (offer.disclosure === 'minimal') {
        print('Stats:');
        print('  Prime Count: ' + offer.data.primeCount);
        print('  Has BDI: ' + (offer.data.hasBDI ? 'YES' : 'NO'));
        print('  Has Rooster: ' + (offer.data.hasRooster ? 'YES' : 'NO'));
      } else if (offer.disclosure === 'partial') {
        print('Revealed Primes: ' + offer.data.revealedPrimes.join(', '));
        print('Hidden: ' + offer.data.hiddenCount + ' primes');
        print('Total Flow: ' + offer.data.totalFlow + 'M');
      } else if (offer.disclosure === 'tunnels') {
        print('Tunnels: ' + offer.data.tunnelCount);
        print('Sidechannels: ' + offer.data.sidechannelCount);
        print('Strengths: ' + offer.data.tunnelStrengths.join('M, ') + 'M');
      } else if (offer.disclosure === 'full') {
        print('Primes: ' + offer.data.primes.join(', '));
        print('Tunnels: ' + offer.data.tunnels.length);
        print('Sidechannels: ' + offer.data.sidechannels.length);
        print('');
        print('[A] Accept loadout  [R] Reject');
      }
      
      print('');
      
      // Accept trade
      if (offer.disclosure === 'full') {
        const acceptHandler = (e) => {
          if (e.key.toUpperCase() === 'A') {
            document.removeEventListener('keydown', acceptHandler);
            ship.primes = new Set(offer.data.primes);
            ship.tunnels = offer.data.tunnels;
            ship.sidechannels = offer.data.sidechannels;
            print('âœ“ Loadout accepted!');
            saveLocal();
            render();
          } else if (e.key.toUpperCase() === 'R') {
            document.removeEventListener('keydown', acceptHandler);
            print('âœ— Trade rejected');
            render();
          }
        };
        document.addEventListener('keydown', acceptHandler);
      }
    } catch (e) {
      print('âœ— Invalid trade offer');
    }
  }
}

// WASM stub (would load actual 8080/ZX81 emulator)
async function loadWasm() {
  print('Loading WASM emulator...');
  // In production: fetch('8080-emulator.wasm')
  print('âœ“ 8080 emulator loaded');
  print('âœ“ ZX81 compatibility mode enabled');
  print('');
}

// Initialize
loadWasm().then(() => {
  // Try to load from localStorage first
  const saved = localStorage.getItem('monster-ship');
  if (saved) {
    try {
      const loaded = JSON.parse(saved);
      ship.primes = new Set(loaded.primes);
      ship.tunnels = loaded.tunnels || [];
      ship.sidechannels = loaded.sidechannels || [];
    } catch (e) {}
  }
  
  // Check for trade offer
  loadTradeOffer();
  
  render();
});

console.log('ğŸ“ Monster BBS Door Game initialized');
console.log('ğŸ“¼ ZK-RDF tape loading enabled');
console.log('ğŸ”€ Sidechannel tunneling: yo dawg mode active');
console.log('ğŸ”’ ZK proof: Monster conformance without revealing data');
console.log('ğŸ’± Trade offers: selective disclosure enabled');
</script>
</body>
</html>
